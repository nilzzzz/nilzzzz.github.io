I"<p>编者按：最近被算法虐的不要不要的，还是那句话拒绝算法就是拒绝成为一流，而想要有好的算法能力在我看来一定是勤加练习加长时间的积累与训练，现在我就十分后悔没有在前两年扎实我的算法能力，如今到了升级打怪的时候才发现内力不够。。。从今以后重新做人。</p>
<h3 id="第七届省赛ｂ组第一题-煤球数目-煤球问题">第七届省赛Ｂ组第一题 煤球数目 煤球问题</h3>

<p>有一堆煤球，堆成三角棱锥形。
具体： 第一层放1个， 第二层3个（排列成三角形）， 第三层6个（排列成三角形）， 第四层10个（排列成三角形）， …. 如果一共有100层，共有多少个煤球？</p>

<p>请填表示煤球总数目的数字</p>

<p><img src="https://blog-1258233124.cos.ap-beijing.myqcloud.com/lanqiaozhipo.png" alt="此处输入图片的描述" /></p>

<h3 id="递归">递归</h3>
<h4 id="递归方法基本步骤">递归方法基本步骤</h4>
<blockquote>
  <ul>
    <li>（1） 根据实际构建递归关系</li>
    <li>（2）确定递归边界</li>
    <li>（3）编写递归函数</li>
    <li>（4）设计主函数调用递归函数
      <h4 id="排队购票">排队购票</h4>
    </li>
  </ul>
</blockquote>
<font color="blue">案例提出：</font>
<p>一场球赛开始前，售票工作正在紧张进行中。
每张球票为50元，有m+n个人排队等待狗牌，其中有m个人手持50元的钞票，另外n个人手持100元的钞票。</p>
<font color="blue">求出m+n个人排队购票</font>
<p>，使售票处不至于出现找不开钱的局面的不同排队种数。
（约定：开始售票时售票处没有零钱，拿同样面值钞票的人对换位置为同一种排队。）</p>

<h4 id="递归设计要点">递归设计要点</h4>

<p>令f(m,n)表示有m个人手持50元的钞票，n个人手持100元的钞票时共有的排队总数。 分以下3种情况来讨论。</p>
<blockquote>
  <ul>
    <li>(1) n=0 n=0意味着排队购票的所有人手中拿的 都是50元的钱币，注意到拿同样面值钞 票的人对换位置为同一种排队，那么这 m个人的排队总数为1，即f(m,0)=1。</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>(2）m&lt;n   当m&lt;n时, 即购票的人中持50元的人数
小于持100元的钞票，即使把m张50元 的钞票都找出去，仍会出现找不开钱的 局面，这时排队总数为0，即f(m,n)=0。</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>(3）其它情况
① 第m+n个人手持100元的钞票，则在他之前的 m+n-1个人中有m个人手持50元的钞票，有n-1个人 手持100元的钞票，此种情况共有f(m,n-1)。
② 第m+n个人手持50元的钞票，则在他之前的 m+n-1个人中有m-1个人手持50元的钞票，有n个人 手持100元的钞票，此种情况共有f(m-1,n)。 由加法原理得到f(m,n)的递归关系： f(m,n)=f(m,n-1)+f(m-1,n) 初始条件： 
当m&lt;n时，f(m,n)=0
当n=0时，f(m,n)=1</li>
  </ul>
</blockquote>

<h3 id="皇后问题的回溯举例">皇后问题的回溯举例</h3>

<p><img src="https://blog-1258233124.cos.ap-beijing.myqcloud.com/shousuanshi1.png" alt="此处输入图片的描述" /></p>

<h4 id="回溯剖析与描述">回溯剖析与描述</h4>

<font color="blue">（1） 回溯求解的问题P</font>
<p>对于已知的由n元组(x1,x2,…,xn)组成的一个状态空间E={(x1,x2,…,xn)|xi∈si,i=1,2,…,n}，给定关于 n元组中的约束集D，要求E中满足D的全部约束条件的所有n元组。
对于约束集D具有完备性的问题P，一旦检测断定某个j元组(x1,x2,…,xj)违反D中仅涉及x1,x2,…,xj的 一个约束，就可以肯定，以(x1,x2,…,xj)为前缀的任何n元组(x1,x2,…,xj,xj+1,…,xn)都不会是问题P 的解，因而就不必去搜索它们，省略了对部分元素(xj+1,…,xn)的操作与测试。</p>

<font color="blue">（2） 回溯描述</font>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>对于一般含参量m,n的搜索问题,输入正整数n,m,(n≥m) i=1;a[i]=&lt;元素初值&gt;;
while (1)
{for(g=1,k=i-1;k&gt;=1;k--) 
if( &lt;约束条件1&gt; ) g=0; // 检测约束条件,不满足则返回 
if(g &amp;&amp; &lt;约束条件2&gt;) printf(a[1：m]); // 输出解 
if(i&lt;n &amp;&amp; g) {i++;a[i]=&lt;取值点&gt;;continue;} 
while(a[i]=&lt;回溯点&gt; &amp;&amp; i&gt;1) i--;  // 向前回溯 
if(a[i]==n &amp;&amp; i==1) break; // 退出循环，结束 
else a[i]=a[i]+1; 
} 
i=1;a[i]=1;
while (1) 
{ g=1;for(k=i-1;k&gt;=1;k--) 
if(a[i]=a[k] || abs(a[i]-a[k])=i-k) g=0;                       // 检测约束条件,不满足则返回 
if(g &amp;&amp; i==4) printf(a[1：4]);      // 输出一个解 
if(i&lt;4 &amp;&amp; g) {i++;a[i]=1;continue;}
while(a[i]==4 &amp;&amp; i&gt;1) i--;    // 向前回溯 
if(a[i]==4 &amp;&amp; i==1) break;  //退出循环结束探索 
else a[i]=a[i]+1;
}
</code></pre></div></div>

<h3 id="桥本分数式">桥本分数式</h3>

:ET