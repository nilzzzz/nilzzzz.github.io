I"1 <h3 id="1adv-150-周期字串">1.ADV-150 周期字串</h3>
<p>时间限制：1.0s        内存限制：256.0MB
<img src="https://blog-1258233124.cos.ap-beijing.myqcloud.com/%E5%91%A8%E6%9C%9F%E5%AD%97%E4%B8%B2.png" alt="此处输入图片的描述" /></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main(){
	string str,s1,s2,ans;
	int result;
	while(cin&gt;&gt;str){
		int len=str.length();
		ans=str;
		for(int i=1;i&lt;=len;i++){
			if(len%i!=0)
				continue;
			s1=str.substr(0,i);//获得字符串str中 从第0位开始的长度为i的字符串,默认时的长度为从开始位置到尾
			int flag=1;
			for(int j=i;j&lt;len;j+=i){
				s2=str.substr(j,i);
				if(s1!=s2){
					flag=0;break;
				}
			}
			if(flag){
				result=i;break;
			}
		}
		cout&lt;&lt;result&lt;&lt;endl;
	}
	return 0;
}

</code></pre></div></div>
<h3 id="2adv-155">2.ADV-155</h3>
<p>问题描述<br />
　　第一分钟，上帝说：要有题。于是就有了L，Y，M，C<br />
　　第二分钟，LYC说：要有向量。于是就有了长度为n写满随机整数的向量<br />
　　第三分钟，YUHCH说：要有查询。于是就有了Q个查询，查询向量的一段区间内元素的最小值<br />
　　第四分钟，MZC说：要有限。于是就有了数据范围<br />
　　第五分钟，CS说：要有做题的。说完众神一哄而散，留你来收拾此题<br />
输入格式<br />
　　第一行两个正整数n和Q，表示向量长度和查询个数<br />
　　接下来一行n个整数，依次对应向量中元素：a[0]，a<a href="https://blog-1258233124.cos.ap-beijing.myqcloud.com/%E5%91%A8%E6%9C%9F%E5%AD%97%E4%B8%B2.png">1</a>，…，a[n-1]<br />
　　接下来Q行，每行两个正整数lo，hi，表示查询区间[lo, hi]中的最小值，即min(a[lo],a[lo+1],…,a[hi])。<br />
输出格式<br />
　　共Q行，依次对应每个查询的结果，即向量在对应查询区间中的最小值。<br />
<strong>样例输入</strong><br />
7 4<br />
1 -1 -4 8 1 2 -7<br />
0 0<br />
1 3<br />
4 5<br />
0 6<br />
<strong>样例输出</strong><br />
1<br />
-4<br />
1<br />
-7<br />
<strong>样例说明</strong><br />
　　第一个查询[0,0]表示求min{a[0]}=min{1}=1<br />
　　第二个查询[1,3]表示求min{a<a href="https://blog-1258233124.cos.ap-beijing.myqcloud.com/%E5%91%A8%E6%9C%9F%E5%AD%97%E4%B8%B2.png">1</a>,a<a href="https://blog-1258233124.cos.ap-beijing.myqcloud.com/%E8%93%9D%E6%A1%A5adv164.png">2</a>,a[3]}=min{-1,-4,8}=-4<br />
　　第三个查询[4,5]表示求min{a[4],a[5]}=min{1,2}=1<br />
　　第四个查询[0,6]表示查询整个向量，求min{a[0..6]}=min{1,-1,-4,8,1,2,-7}=-7<br />
<strong>数据规模和约定</strong><br />
　　1&lt;=n&lt;=1984，1&lt;=Q&lt;=1988，向量中随机整数的绝对值不超过1,000</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include&lt;stdio.h&gt;
int c[2000];
int min(int a,int b,int c[])
{
	int i,min = c[a];
	for(i = a;i&lt;=b;i++)
		if(c[i]&lt;min)
			min = c[i];
	return min;
}


int main()
{
	int n,Q,i,lo,hi;
	scanf("%d%d",&amp;n,&amp;Q);
	for(i = 0;i&lt;n;i++)
		scanf("%d",&amp;c[i]);
	for(i = 0;i&lt;Q;i++)
	{
		scanf("%d%d",&amp;lo,&amp;hi);
		printf("%d\n",min(lo,hi,c));
	}
	return 0;
} 

</code></pre></div></div>

<h3 id="3adv-164dp">3.ADV-164(DP)</h3>
<p>问题描述<br />
　　金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天<br />
对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。
今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，<br />
下表就是一些主件与附件的例子：<br />
<img src="https://blog-1258233124.cos.ap-beijing.myqcloud.com/%E8%93%9D%E6%A1%A5adv164.png" alt="此处输入图片的描述" />
<strong>如果要买归类为附件的物品，必须先买该附件所属的主件</strong>。每个主件可以有0个、1个或2个附件。<br />
附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，<br />
分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。<br />
他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。<br />
设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为j_1，j_2，……，j_k，则所求的总和为：<br />
v[j_1]<em>w[j_1]+v[j_2]</em>w[j_2]+ …+v[j_k]<em>w[j_k]。（其中</em>为乘号)<br />　　
请你帮助金明设计一个满足要求的购物单。<br />
输入格式<br />
　 输入文件budget.in 的第1行，为两个正整数，用一个空格隔开：N m（其中N（&lt;32000）表示总钱数，<br />
m（&lt;60）为希望购买物品的个数。）从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，<br />
每行有3个非负整数　v p q（其中v表示该物品的价格（v&lt;10000），p表示该物品的重要度（1~5），<br />
q表示该物品是主件还是附件。如果q=0，表示该物品为主件，如果q&gt;0，表示该物品为附件，q是所属主件的编号）<br />
输出格式<br />
　输出文件budget.out只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（&lt;200000）<br />
样例输入<br />
1000 5<br />
800 2 0<br />
400 5 1<br />
300 5 1<br />
400 3 0<br />
500 2 0<br />
样例输出<br />
2200<br />
【思路】<br />
对于经典的背包问题，我们都知道每个物品有两种决策，即放入或不放入。<br />
但这个题多了一些限制条件，所以每个物品的决策不止两个了。但由于题目里有这句话“每个主件可以有0个、1个或2个附件”，<br />
所以可以这样做：<br />
    如果第i号物品为附件，就直接忽视了它。<br />
    如果第i号物品为主件，那么就有这么几种决策：不放入它；仅放入它；仅放入它和它的第一个附件；<br />
	仅放入它和它的第二个附件；放入它和它的所有附件。<br />
    由此得出算法。<br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
#include&lt;stdio.h&gt;  
int v[70]; // 价格 
int p[70]; // 重要度 
int q[70]; //  主/附件 
int f[50000];  
int max(int a,int b)  
{   return a &gt; b ? a : b;   }  
int main()  
{  
    int n,m;  
    int i,j,k;  
    int t1,t2;  
    scanf("%d%d",&amp;n,&amp;m);  
    for(i = 1; i &lt;= m; i++)  
    {  
        scanf("%d%d%d",&amp;v[i],&amp;p[i],&amp;q[i]);  
    }  
    for(i = 1; i &lt;= m; i++)  
    {  
        t1=0;  
        t2=0;  
        if(q[i] == 0)  //主件  
        {  
           for(k = i+1;k &lt;= m; k++) //附件1   
              if(q[k] == i)                       
               {  
                  t1 = k;  //保存附件1的位置
                  break;  
               }  
           for(k = t1+1;k &lt;= m; k++)//附件2   
             if(q[k] == i )                        
              {  
                  t2 = k; //保存附件2的位置 
                  break;  
              }   
          for(j = n; j &gt;= v[i]; j--)  
            {         
      
              f[j] = max(f[j-v[i]]+v[i]*p[i],f[j]);   //取主件  

              if(( j-v[i]-v[t1])&gt;=0 )//取附件1  
                 f[j] = max(f[j-v[i]-v[t1]]+v[i]*p[i]+v[t1]*p[t1],f[j]);  

              if( j-v[i]-v[t2]&gt;=0 )//取附件2
				f[j] = max(f[j-v[i]-v[t2]]+v[i]*p[i]+v[t2]*p[t2],f[j]);  

              if((j-v[i]-v[t1]-v[t2])&gt;=0) //附件1,2都取  	  
                f[j] = max(f[j-v[i]-v[t1]-v[t2]]+v[i]*p[i]+v[t1]*p[t1]+v[t2]*p[t2],f[j]);           
            }  
        }  
    }  
    printf("%d\n",f[n]);  
      
    return 0;  
}  
</code></pre></div></div>

<p>　　
　　</p>

:ET