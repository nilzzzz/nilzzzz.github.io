I"<p><a href="http://acm.hrbust.edu.cn/problems">oj-acm专项分类练习</a></p>
<h3 id="分治算法">分治算法</h3>
<h3 id="一基本概念">一、基本概念</h3>
<p>在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……
    任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。</p>
<h3 id="二基本思想及策略">二、基本思想及策略</h3>
<p><strong>分治法</strong>的设计思想是：将一个难以直接解决的大问题，分割成一些规«br/&gt;模较小的相同问题，以便各个击破，分而治之。<br />
   <strong>分治策略</strong>是：对于一个规模为n的问题，若该问题可以容易地解决<br />（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子<br />问题，这些子问题互相独立且与原问题形式相同，递归地解这些子<br />问题，然后将各子问题的解合并得到原问题的解。<br />这种算法设计策略叫做分治法。<br />
   如果原问题可分割成k个子问题,1&lt;k≤n，<br />
   且这些子问题都可解并可利用这些子问题的解求出原问题的解，<br />那么这种分治法就是可行的。<br />由分治法产生的子问题往往是原问题的较小模式，<br />这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，<br />可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。<br />这自然导致递归过程的产生。<br />分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。<br /></p>
<h3 id="三分治法适用的情况">三、分治法适用的情况</h3>
<p>分治法所能解决的问题一般具有以下几个特征：<br /></p>

<ol>
  <li>该问题的规模缩小到一定的程度就可以容易地解决</li>
  <li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</li>
  <li>利用该问题分解出的子问题的解可以合并为该问题的解；</li>
  <li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</li>
</ol>

<p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；<br />
第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；<br /> 
第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。<br />
第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。<br /></p>
<h3 id="四分治法的基本步骤">四、分治法的基本步骤</h3>
<p>分治法在每一层递归上都有三个步骤：<br />
    step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；<br />
    step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题<br />
    step3 合并：将各个子问题的解合并为原问题的解。<br />
它的一般的算法设计模式如下：<br />
    Divide-and-Conquer(P)<br />
    1. if |P|≤n0<br />
    2. then return(ADHOC(P))<br />
    3. 将P分解为较小的子问题 P1 ,P2 ,…,Pk<br />
    4. for i←1 to k<br />
    5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi<br />
    6. T ← MERGE(y1,y2,…,yk) △ 合并子问题<br />
    7. return(T)<br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，
问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，
用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。
算法MERGE(y1,y2,...,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,...,Pk的相应的解y1,y2,...,yk合并为P的解。
</code></pre></div></div>

<h3 id="五分治法的复杂性分析">五、分治法的复杂性分析</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。
设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。
再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。
用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：
T（n）= k T(n/m)+f(n)
通过迭代法求得方程的解：
递归方程及其解只给出n等于m的方幂时T(n)的值，
但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)
的增长速度。通常假定T(n)是单调上升的，从而当  
mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。 
</code></pre></div></div>

<h3 id="六可使用分治法求解的一些经典问题">六、可使用分治法求解的一些经典问题</h3>

<ol>
  <li>二分搜索</li>
  <li>大整数乘法</li>
  <li>Strassen矩阵乘法</li>
  <li>棋盘覆盖</li>
  <li>合并排序</li>
  <li>快速排序</li>
  <li>线性时间选择</li>
  <li>最接近点对问题</li>
  <li>循环赛日程表</li>
  <li>汉诺塔</li>
</ol>

<h3 id="七依据分治法设计程序时的思维过程">七、依据分治法设计程序时的思维过程</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。
</code></pre></div></div>

<ol>
  <li>一定是先找到最小问题规模时的求解方法</li>
  <li>然后考虑随着问题规模增大时的求解方法</li>
  <li>找到求解的递归函数式后（各种规模或因子），设计递归程序即可。</li>
</ol>

:ET