---
layout: post
title: 【笔记】JVM之虚拟机栈
tag: JVM
---

也叫Java栈

### 1.概述

虚拟机栈出现的背景

由于跨平台的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的

优点：

**跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令**

Q：有不少Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有Java堆和Java栈（stack）?为什么？

#### 内存中的栈和堆

**栈是运行时的单位，而堆是存储的单位**

即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放在哪儿

![image-20200706164410817](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200706164410817.png)

#### 虚拟机栈基本内容

注意保存方法的局部变量是指**8种基本数据类型，对象的引用地址**

![image-20200706165213943](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200706165213943.png)

![image-20200706165535785](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200706165535785.png)

#### 栈的优点

![image-20200706165935547](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200706165935547.png)

存在OOM 不存在GC

#### 面试题：开发中遇到的异常有哪些？

##### 栈中可能出现的异常

Java虚拟机规范允许**Java栈的大小是动态的或者固定不变的。**

- 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个**StackOverflowError**异常。
- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存区去创建对应的虚拟机栈，那Java虚拟机将会抛出一个**OutOfMemoryError**异常。

##### 设置栈内存大小

我们可以使用参数-Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度

查找官方文档找到Xss使用说明：https://docs.oracle.com/en/java/javase/11/tools/tools-and-command-reference.html

![image-20200706202256741](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200706202256741.png)

```
 /**
 *  默认情况下：count : 11414
 *  设置栈的大小： -Xss256k : count : 2469
 */
public class StackErrorTest {
        private static int count = 1;
        public static void main(String[] args) {
            System.out.println(count);
            count++;
            main(args);
        }

}
```

设置栈的大小 ：Run --> Edit Configuration-->**-Xss256k**

![image-20200706202853485](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200706202853485.png)

### 2.栈的存储单位

#### 栈中存储什么？

- 每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在
- 在这个线程上正在执行的每个方法都各自对应一个栈帧
- 栈帧是一个内存区块，是一个数据库，维系着方法执行过程中的各种数据信息

#### 栈运行原理

![image-20200706204218412](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200706204218412.png)

![image-20200706205818501](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200706205818501.png)

#### 栈帧的内部结构

![image-20200706210103229](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200706210103229.png)

![image-20200706210311835](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200706210311835.png)

### 3.局部变量表（Local Variables）

- ![image-20200706210734154](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200706210734154.png)

![image-20200706221101036](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200706221101036.png)

#### 关于Slot的理解

![image-20200707152008245](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707152008245.png)

![image-20200707152935036](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707152935036.png)

下图说明：<font color="red">如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会放在index为0的slot处。</font>

![image-20200707154557525](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707154557525.png)

![image-20200707155201439](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707155201439.png)

slot重复利用

![image-20200707155512287](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707155512287.png)

```
public void test4() {
    int a = 0;
    {
        int b = 0;
        b = a + 1;
    }
    //变量c使用之前已经销毁的变量b占据的slot的位置
    int c = a + 1;
}
```

#### 静态变量与局部变量对比

```
变量的分类：按照数据类型分：① 基本数据类型  ② 引用数据类型
            按照在类中声明的位置分：① 成员变量：在使用前，都经历过默认初始化赋值
                                  类变量（static修饰的）： linking的prepare阶段：给类变量默认赋值  ---> initial阶												段：给类变量显式赋值即静态代码块赋值
                                  
                                  实例变量（没有static修饰的）：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋										   值
                                ② 局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过
```

![image-20200707162543451](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707162543451.png)

#### 补充说明

- 在栈帧中，与性能调优关系最为密切的部分就是局部变量表，在方法执行时，虚拟机使用局部变量表完成方法的传递
- <font color="red">局部变量表中的表量也是重要的垃圾回收根节点（GCRoot）,只要被局部变量表中直接或间接引用的对象都不会被回收。</font>

### 4.操作数栈（Operand Stack）

![image-20200707163346814](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707163346814.png)

![image-20200707163735130](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707163735130.png)

数组实现的，所以深度在编译期就定义好了

![image-20200707164246333](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707164246333.png)

![image-20200707164311421](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707164311421.png)



### 5.代码追踪

![image-20200707165357063](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707165357063.png)

或者使用jclasslib插件

![image-20200707170732646](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707170732646.png)

![image-20200707170818393](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707170818393.png)



### 6.栈顶缓存技术（Top-of-Stack）

![image-20200707171801794](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707171801794.png)



寄存器相对于栈，指令更少，执行速度更快

### 7.动态链表

![image-20200707172427094](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707172427094.png)

![image-20200707173445364](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707173445364.png)

![image-20200707174158072](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707174158072.png)

### 8.方法的调用：解析与分派

#### 静态链接和动态链接

![image-20200707174611527](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707174611527.png)

#### 早期绑定和晚期绑定

![image-20200707175026666](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707175026666.png)

![image-20200707180533778](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707180533778.png)

#### 虚方法和非虚方法

非虚方法：

- 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的，这样的方法称为<font color="red">非虚方法。</font>
- 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法
- 其他方法称为虚方法

子类对象的多态性的使用前提：

1. 类的继承关系
2. 方法的重写

![image-20200707181938963](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200707181938963.png)

```
class Father {
    public Father() {
        System.out.println("father的构造器");
    }

    public static void showStatic(String str) {
        System.out.println("father " + str);
    }

    public final void showFinal() {
        System.out.println("father show final");
    }

    public void showCommon() {
        System.out.println("father 普通方法");
    }
}

public class Son extends Father {
    public Son() {
        //invokespecial
        super();
    }
    public Son(int age) {
        //invokespecial
        this();
    }
    //不是重写的父类的静态方法，因为静态方法不能被重写！
    public static void showStatic(String str) {
        System.out.println("son " + str);
    }
    private void showPrivate(String str) {
        System.out.println("son private" + str);
    }

    public void show() {
        //invokestatic
        showStatic("atguigu.com");
        //invokestatic
        super.showStatic("good!");
        //invokespecial
        showPrivate("hello!");
        //invokespecial
        super.showCommon();

        //invokevirtual
        showFinal();//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。
        //虚方法如下：
        //invokevirtual
        showCommon();
        info();

        MethodInterface in = null;
        //invokeinterface
        in.methodA();
    }

    public void info(){

    }

    public void display(Father f){
        f.showCommon();
    }

    public static void main(String[] args) {
        Son so = new Son();
        so.show();
    }
}

interface MethodInterface{
    void methodA();
}

```

#### invokedynamic

![image-20200709162419061](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200709162419061.png)

![image-20200709162459440](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200709162459440.png)

#### 方法重写的本质

![image-20200709163447942](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200709163447942.png)

#### 虚方法表

![image-20200709163713598](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200709163713598.png)

![image-20200709163843415](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200709163843415.png)

### 9.方法返回地址（return address）

存放调用该方法的PC寄存器的值。

![image-20200709165038150](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200709165038150.png)

![image-20200709165236868](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200709165236868.png)

![image-20200709165832246](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200709165832246.png)

![image-20200709170307813](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200709170307813.png)

![image-20200709170217928](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200709170217928.png)

### 10.一些附加信息

栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。

### 11.栈的相关面试

![image-20200709170759097](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image-20200709170759097.png)

栈不需要，栈自己会出栈入栈

对于一个栈本身来说，栈内存越大越好，但是栈时线程私有的，每个线程都会分配一部分虚拟机栈的空间，一个线程栈分配大了，其他线程空间就少了

```
* 面试题：
* 方法中定义的局部变量是否线程安全？具体情况具体分析
*
*   何为线程安全？
*      如果只有一个线程才可以操作此数据，则必是线程安全的。
*      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。
```

```
public class StringBuilderTest {

    int num = 10;

    //s1的声明方式是线程安全的
    public static void method1(){
        //StringBuilder:线程不安全
        StringBuilder s1 = new StringBuilder();
        s1.append("a");
        s1.append("b");
        //...
    }
    //sBuilder的操作过程：是线程不安全的
    public static void method2(StringBuilder sBuilder){
        sBuilder.append("a");
        sBuilder.append("b");
        //...
    }
    //s1的操作：是线程不安全的
    public static StringBuilder method3(){
        StringBuilder s1 = new StringBuilder();
        s1.append("a");
        s1.append("b");
        //比上面s1多了个return 就可能被其他线程共享
        return s1;
    }
    //s1的操作：是线程安全的
    public static String method4(){
        StringBuilder s1 = new StringBuilder();
        s1.append("a");
        s1.append("b");
        //s1调用了toString方法，相对于上面方法三，s1在方法内销亡了
        /**
         * 因为：public String toString() {
         *         // Create a copy, don't share the array
         *         return new String(value, 0, count);
         *     }
         */
        //可能s1.toString()是不安全的，但是s1是安全的
        return s1.toString();
    }

    public static void main(String[] args) {
        StringBuilder s = new StringBuilder();


        new Thread(() -> {
            s.append("a");
            s.append("b");
        }).start();

        method2(s);

    }

}
```