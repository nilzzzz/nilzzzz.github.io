---
layout: post
title: 红黑树
tag: 数据结构
---

# 红黑树

## 二叉查找树

二叉搜索树又叫二叉查找树、二叉排序树，我们先看一下典型的二叉搜索树，这样的二叉树有何规则特点呢？



二叉搜索树有如下几个特点：

- **节点的左子树小于节点本身**
- **节点的右子树大于节点本身**
- **左右子树同样为二叉搜索树**



下图就是一棵典型的二叉搜索树：

![image-20200528101157219](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/101203-683906.png)

## 2-3树

## 红黑树

1. 每个节点非黑即红
2. 根节点总是黑色的
3. 每个叶子节点都是黑色的空节点（NIL）
4. 连接红色节点的两个子节点都是黑色，反之不一定（红黑树不会出现相邻的红色节点）
5. 从任意节点出发，到每个叶子节点的路径中包含相同数量的黑色节点
6. 新加入到红黑树的节点为红色节点

因为红黑树椰树均衡二叉树，需要具备自动维持平衡的性质，上面的六条就是红黑树给出的自动维持平衡所具备的规则。



![image-20200528073507110](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/073509-109653.png)

![image-20200528080521413](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/080728-50479.png)

首先解读一下规则，除了字面上看到的意思，还隐藏了哪些意思呢？

**①从根节点到叶子节点的最长路径不大于最短路径的 2 倍**



怎么样的路径算最短路径？从规则 5 中，我们知道从根节点到每个叶子节点的黑色节点数量是一样的，那么纯由黑色节点组成的路径就是最短路径。



什么样的路径算是最长路径？根据规则 4 和规则 3，若有红色节点，则必然有一个连接的黑色节点，当红色节点和黑色节点数量相同时，就是最长路径，也就是黑色节点（或红色节点）*2。



**②为什么说新加入到红黑树中的节点为红色节点**



从规则 4 中知道，当前红黑树中从根节点到每个叶子节点的黑色节点数量是一样的，此时假如新的是黑色节点的话，必然破坏规则。



但加入红色节点却不一定，除非其父节点就是红色节点，因此加入红色节点，破坏规则的可能性小一些，下面我们也会举例来说明。



什么情况下，红黑树的结构会被破坏呢？破坏后又怎么维持平衡，维持平衡主要通过两种方式【变色】和【旋转】，【旋转】又分【左旋】和【右旋】，两种方式可相互结合。



下面我们从插入和删除两种场景来举例说明。

## 红黑树节点插入

当我们插入值为 66 的节点时，红黑树变成了这样：

![image-20200528094242703](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/094244-633480.png)



很明显，这个时候结构依然遵循着上述 6 大规则，无需启动自动平衡机制调整节点平衡状态。

如果再向里面插入值为 51 的节点，这个时候红黑树变成了这样：

![image-20200528094333511](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/094338-166356.png)

很明显现在的结构不遵循规则 4 了，这个时候就需要启动自动平衡机制调整节点平衡状态。

## 变色

我们可以通过变色的方式，使结构满足红黑树的规则：

- 首先解决结构不遵循规则 4 这一点（红色节点相连，节点 49-51），需将节点 49 改为黑色。
- 此时我们发现又违反了规则 5（56-45-49-51-XX 路径中黑色节点超过了其他路径），那么我们将节点 45 改为红色节点。
- 哈哈，妹的，又违反了规则 4（红色节点相连，节点 56-45-43），那么我们将节点 56 和节点 43 改为黑色节点。
- 但是我们发现此时又违反了规则 5（60-56-XX 路径的黑色节点比 60-68-XX 的黑色节点多），因此我们需要调整节点 68 为黑色。
- 完成！

![image-20200528094657328](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/094700-378690.png)

最终调整完成后的树为：

![image-20200528094724747](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/094727-84722.png)

但并不是什么时候都那么幸运，可以直接通过变色就达成目的，大多数时候还需要通过旋转来解决。



如在下面这棵树的基础上，加入节点 65：

![image-20200528094807862](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/094812-15290.png)

插入节点 65 后进行以下步骤：



![image-20200528095103895](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/095115-281574.png)

这个时候，你会发现对于节点 64 无论是红色节点还是黑色节点，都会违反规则 5，路径中的黑色节点始终无法达成一致，这个时候仅通过【变色】已经无法达成目的。

我们需要通过旋转操作，当然【旋转】操作一般还需要搭配【变色】操作。旋转包括【左旋】和【右旋】。

##### **左旋：**逆时针旋转两个节点，让一个节点被其右子节点取代，而该节点成为右子节点的左子节点。



**左旋操作步骤如下：**首先断开节点 PL 与右子节点 G 的关系，同时将其右子节点的引用指向节点 C2；然后断开节点 G 与左子节点 C2 的关系，同时将 G 的左子节点的应用指向节点 PL。

![image-20200528095413522](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/095414-168353.png)

##### **右旋：**顺时针旋转两个节点，让一个节点被其左子节点取代，而该节点成为左子节点的右子节点。



**右旋操作步骤如下：**首先断开节点 G 与左子节点 PL 的关系，同时将其左子节点的引用指向节点 C2；然后断开节点 PL 与右子节点 C2 的关系，同时将 PL 的右子节点的应用指向节点 G。

![image-20200528095509390](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/095511-577312.png)

无法通过变色而进行旋转的场景分为以下四种：

### **左左节点旋转**

这种情况下，父节点和插入的节点都是左节点，如下图(旋转原始图1)这种情况下，我们要插入节点 65。



**规则如下：**以祖父节点【右旋】，搭配【变色】。

![image-20200528095742677](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/095744-162467.png)

按照规则，步骤如下：

![image-20200528095815287](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/095817-101168.png)

### **左右节点旋转**

这种情况下，父节点是左节点，插入的节点是右节点，在旋转原始图 1 中，我们要插入节点 67。

**规则如下：**先父节点【左旋】，然后祖父节点【右旋】，搭配【变色】。

按照规则，步骤如下：

![image-20200528100237897](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/100239-680119.png)

### 右左节点旋转

这种情况下，父节点是右节点，插入的节点是左节点，如下图（旋转原始图 2）这种情况，我们要插入节点 68。



**规则如下：**先父节点【右旋】，然后祖父节点【左旋】，搭配【变色】。

![image-20200528100503402](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/100504-136562.png)

按照规则，步骤如下：

![image-20200528100555057](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/100559-154784.png)

## **右右节点旋转**

这种情况下，父节点和插入的节点都是右节点，在旋转原始图 2 中，我们要插入节点 70。



**规则如下：**以祖父节点【左旋】，搭配【变色】。

按照规则，步骤如下：

![image-20200528100750555](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/100751-955504.png)

## **红黑树插入总结**

### 红黑树插入总结如下图：

![image-20200528101509405](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/101510-196387.png)

## 红黑树节点删除

相比较于红黑树的节点插入，删除节点更为复杂，我们从子节点是否为 null 和红色为思考维度来讨论

###  **子节点至少有一个为 null**

当待删除的节点的子节点至少有一个为 null 节点时，删除了该节点后，将其有值的节点取代当前节点即可。



若都为 null，则将当前节点设置为 null，当然如果违反规则了，则按需调整，如【变色】以及【旋转】。

![image-20200528101750368](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/101752-212372.png)

## **子节点都是非 null 节点**

这种情况下，第一步：找到该节点的前驱或者后继。





**前驱：**左子树中值最大的节点（可得出其最多只有一个非 null 子节点，可能都为 null）。



**后继：**右子树中值最小的节点（可得出其最多只有一个非 null 子节点，可能都为 null）。



前驱和后继都是值最接近该节点值的节点，类似于该节点.prev=前驱，该节点.next=后继。



第二步：将前驱或者后继的值复制到该节点中，然后删掉前驱或者后继。



如果删除的是左节点，则将前驱的值复制到该节点中，然后删除前驱；如果删除的是右节点，则将后继的值复制到该节点中，然后删除后继。



这相当于是一种“取巧”的方法，我们删除节点的目的是使该节点的值在红黑树上不存在。



因此专注于该目的，我们并不关注删除节点时是否真是我们想删除的那个节点，同时我们也不需考虑树结构的变化，因为树的结构本身就会因为自动平衡机制而经常进行调整。



前面我们已经说了，我们要删除的实际上是前驱或者后继，因此我们就以前驱为主线来讲解。



后继的学习可参考前驱，包括下面几种情况：



#### **①前驱为黑色节点，并且有一个非 null 子节点**

![image-20200528102739457](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/102740-996844.png)

**分析：**因为要删除的是左节点 64，找到该节点的前驱 63；然后用前驱的值 63替换待删除节点的值 64，此时两个节点（待删除节点和前驱）的值都为 63；



删除前驱 63，此时成为上图过程中间环节，但我们发现其不符合红黑树规则 4，因此需要进行自动平衡调整。这里直接通过【变色】即可完成。



#### **②前驱为黑色节点，同时子节点都为 null**

![image-20200528102425412](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/102426-768258.png)



分析：因为要删除的是左节点 64，找到该节点的前驱 63；然后用前驱的值 63替换待删除节点的值 64，此时两个节点（待删除节点和前驱）的值都为 63；



删除前驱 63，此时成为上图过程中间环节，但我们发现其不符合红黑树规则 4，因此需要进行自动平衡调整。这里直接通过【变色】即可完成。



#### **②前驱为黑色节点，同时子节点都为 null**

![image-20200528103159691](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/103201-173447.png)

**分析：**因为要删除的是左节点 64，找到该节点的前驱 63；然后用前驱的值 63 替换待删除节点的值 64，此时两个节点（待删除节点和前驱）的值都为 63。



删除前驱 63，此时成为上图过程中间环节，但我们发现其不符合红黑树规则 5，因此需要进行自动平衡调整。这里直接通过【变色】即可完成。

#### **③前驱为红色节点，同时子节点都为 null**

![image-20200528103306442](https://gitee.com/XiaoShenKeHeBen/Static/raw/master/image/202005/28/103306-986174.png)

**分析：**因为要删除的是左节点 64，找到该节点的前驱 63；然后用前驱的值 63替换待删除节点的值 64，此时两个节点（待删除节点和前驱）的值都为 63；删除前驱 63，树的结构并没有打破规则。



**红黑树删除总结**



红黑树删除的情况比较多，但也就存在以下情况：

- 删除的是根节点，则直接将根节点置为 null。
- 待删除节点的左右子节点都为 null，删除时将该节点置为 null。
- 待删除节点的左右子节点有一个有值，则用有值的节点替换该节点即可。
- 待删除节点的左右子节点都不为 null，则找前驱或者后继，将前驱或者后继的值复制到该节点中，然后删除前驱或者后继。
- 节点删除后可能会造成红黑树的不平衡，这时我们需通过【变色】+【旋转】的方式来调整，使之平衡，上面也给出了例子，建议大家多多练习，而不必背下来。



总结



本文主要介绍了红黑树的相关原理，首先红黑树的基础二叉搜索树，我们先简单说了一下二叉搜索树，并且讲了一下搜索的流程。

然后就针对红黑树的六大规则特点，红黑树的插入操作，删除操作，都使用了大量的图形来加以说明。

技术都是练出来的，有时候很多似是而非的地方，当动笔去写的时候，其实很好理解。

红黑树的使用非常广泛，如 TreeMap 和 TreeSet 都是基于红黑树实现的，而 JDK8 中 HashMap 当链表长度大于 8 时也会转化为红黑树。

*作者：梁洪*

*简介：网名工匠初心\，热爱技术，喜欢钻研与分享，6 年 Java 开发经验，专注于 Java 以及 Spring 生态圈，同时也喜欢研究物联网、大数据、AI 等前沿技术，带过 15 人以下的小团队，做过项目管理，现在是一家软件公司的部门经理。*

*出处：https://www.cnblogs.com/LiaHon/p/11203229.html*

文中有部分改动，仅供个人学习。